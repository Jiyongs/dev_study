## 5. 책임과 메시지

### 책임감 분산(diffusion of responsibility) 현상
사건에 대한 목격자가 많으면 많을수록 개인이 느끼는 책임감은 적어진다.   
-> 각 개인에게 책임이 명확하게 주어져야 협력에 참여하기 쉽다

### 책임이 설계의 품질에 미치는 영향
적절한 책임 -> 자율적 객체 -> 유연하고 단순한 협력 -> 전체 애플리케이션의 품질을 결정

### 적절한 책임을 어떻게 결정하면 좋을까
```
Case1. 간결한 책임을 지정   
요청 전송 : 왕 -> 모자장수(목격자) 에게 ‘증언하라’   
요청 응답 : 모자장수(목격자)는 ‘증언한다’
```
-> 요청을 받은 모자장수는 ‘증언할’ 책임을 진다.    
-> 왕은 모자장수가 요청에 대한 책임을 지면, 어떤 방법으로 증언하는지는 신경쓰지 않는다.   
-> 모자장수는 왕의 요청을 받아야만 책임을 수행하지만, 수행방식은 자율적으로 선택할 수 있다.   
```
case2. 디테일한 책임을 지정   
요청 전송 : 왕 -> 모자장수(목격자) 에게 ‘목격했던 장면을 떠올려서, 시간 순서대로 재구성하여, 간결하게 표현하라’   
요청 응답 : 모자장수(목격자)는 ‘목격했던 장면을 떠올려서, 시간 순서대로 재구성하여, 간결하게 표현하라’   
```
-> 요청을 받은 모자장수는 ‘왕이 요청한 조건대로만 증언할’ 책임을 진다.   
-> 모자장수의 자율성을 지나치게 제한하여 더 좋은 증언(떠올리지 않고 기록해둔 장면을 보거나 등)을 할 수 있는 결과를 얻지 못한다.

### 그렇다고 너무 추상적인 책임은 좋지 않다
협력의 의도를 명확히 표현하지 못할 정도로 추상적인 책임은 원하는 결과를 얻을 수 없게 한다.   
```
왕 -> 모자장수(목격자)에게 ‘설명하라’   
모자장수 -> 뭘..설명하지.. 혼란에 빠짐   
```
=> 책임은 ‘어떻게’가 아니라 ‘무엇을’   
=> 설계 중인 협력이 무엇인가에 따라 책임의 추상성과 구체성을 적절히 조절해야 한다

- - -
### 책임을 수행하게 하는 유일한 수단 ‘메시지’
```
메시지 = 메시지 이름 + 메시지 인자   
‘증언하라’ = 메시지 이름   
‘언제 어디서 목격한 것을’(추가 정보) = 메시지 인자   
```   
메시지 전송은 수신자, 메시지 이름, 메시지 인자의 조합이다    
: 모자장수.증언하라(어제, 왕국)    
객체가 수신할 수 있는 메시지의 모양이 책임의 모양을 결정한다   
   
메시지는 객체들이 서로 협력하는데 사용하는 유일한 수단이며, 객체가 그 메시지를 수신할 수 있다는 것은 해당하는 책임을 진다는 것을 의미한다.   
객체는 메시지를 처리하기 위한 방법을 자율적으로 선택한다.   
외부 객체는 메시지(public)만 볼 수 있고, 메시지를 수행하는 객체 내부(private)는 볼 수 없기에 자연스럽게 객체의 외부/내부가 분리된다.   

### 메시지를 처리하는 방법 ‘메서드’
```
메시지 : 송신자 객체가 요청한 책임   
메서드 : 수신자 객체가 메시지를 처리하기 위해 내부적으로 선택하는 방법
```
### 메시지와 메서드의 차이점을 통해 이해하는 다형성
```
다형성 : 서로 다른(타입의) 객체들이 동일한 메시지를 수신 했을 때 서로 다른 메서드를 통해 메시지를 처리할 수 있는 메커니즘   
```
메시지 송신자의 관점에서 중요한 것은 수신자들이(어떤 방법으로 처리한다고 해도) 동일한 책임을 수행하는가 이다.   
따라서 수신자들은 송신자에게 받은 요청을 각자의 방법으로 사용하게 됨으로써 다형성을 이용한다.   
다형성을 사용하면 송신자가 수신자의 종류를 모르더라도 메시지를 전송할 수 있게 한다. 즉, 다형성은 수신자의 종류를 캡슐화한다.   
   
결론적으로, 다형성은 수신자의 종류를 캡슐화 함으로써 다양한 타입의 객체와 협력할 수 있게 하기에.  
다형성을 사용하면 메시지를 이해할 수 있는 어떤 객체와도 협력할 수 있는 유연하고 확장 가능한 구조를 만들 수 있다.   
따라서 객체지향이 유연하고 확장 가능하며 재사용성이 높다는 것에 다형성이 기여하는 것이 크다고 볼 수 있다.

- - -
### 책임-주도 설계의 What/Who 사이클
```
책임-주도 설계에서 어떤 행위(what)가 필요한지를 먼저 결정한 후 해당 행위를 수행할 객체(who)를 결정하는 과정   
```
책임-주도 설계에서는 객체의 특성에 맞아떨어지는 행위만을 설계하지 않는다. 협력이라는 문맥에서 필요한 메시지를 먼저 결정한 뒤, 메시지를 수신하기에 적합한 객체를 선택한다.   
이러한 행위(메시지)가 모여 인터페이스를 구성한다.

### 인터페이스
```
객체가 외부로부터 수신할 수 있는 메시지의 목록 
=> 인터페이스의 예시 : 자동차의 핸들, 변속기, 엑셀, 브레이크, 계기판   
```
특징1. 인터페이스 사용법만 익히면 내부구조나 원리를 몰라도 대상을 조작하거나 의사를 전달할 수 있다.   
-> 운전자는 자동차의 내부구조를 몰라도 운전하는데 문제가 없다.   
특징2. 인터페이스 자체는 변경하지 않고 단순 내부구조나 원리를 변경하는 것은 인터페이스 사용자에게 영향이 없다.   
-> 자동차의 내부구조가 바뀌어도 운전법이 바뀌는 것이 아니다.   
특징3. 인터페이스가 동일하기만 하다면 어떤 대상과도 상호작용할 수 있다.   
-> 자동차 운전법을 알고있다면 어떤 자동차라도 운전할 수 있다.

### 공용 인터페이스
내부에서만 접근 가능한 사적인 인터페이스와 구분하기 위해, 외부에 공개된 인터페이스를 일컫는 말

### 객체지향적 인터페이스
맷 와이스펠드의 3가지 원칙   

1. 더 추상적인 인터페이스   
-> 객체의 자율성을 보장하는 간결한 요청   
2. 최소 인터페이스   
-> 외부에서 사용할 필요 없는 인터페이스는 최대한 노출하지 않기. 객체의 내부를 수정해도 외부에 미치는 영향을 최소화 할 수 있다.   
3. 인터페이스와 구현 간에 차이가 있다는 점을 인식   
-> 객체의 외부와 내부를 명확히 분리하는 것

### 인터페이스와 구현(implementation)의 분리
```
구현 : 객체를 구성하지만 공용 인터페이스에 포함되지 않는 모든 것 (객체의 상태, 메서드)   
```
훌륭한 객체는 구현을 모른 채 인터페이스만 알면 쉽게 상호작용할 수 있는 객체   
객체 설계의 핵심은 객체를 두 개의 분리된 요소로 분할해 설계하는 것이다.   
소프트웨어는 항상 변경되는데 어떤 객체를 수정 했을 때 어떤 객체가 영향을 받는지를 판단하는 것은 어렵다.   
객체의 모든 것이 외부에 공개 되어있다면, 작은 수정도 큰 파급효과를 낼 것이다.   
객체 외부에 영향을 미치는 것은 내부요소가 아닌 공용 인터페이스를 수정할 때 뿐이여야 한다.   
즉, 송신자와 수신자가 구체적인 구현 부분이 아니라 느슨한 인터페이스에 대해서만 결합되도록 만들어야 한다.

### 캡슐화를 통한 정보 은닉
캡슐화의 2가지 관점   
1. 상태와 행위의 캡슐화   
-> 객체는 상태를 변경하고 외부에 응답할 수 있는 행동을 내부에 함께 보관한 후, 외부에서 반드시 접근해야만 하는 행위만 골라 공용 인터페이스에 노출한다. -> 따라서, 캡슐화는 인터페이스와 구현을 분리하거나 상태를 숨김으로서 자율적 객체를 만들기 위한 전제 조건이다.   
2. 사적인 비밀의 캡슐화   
-> 변경이 빈번한 상태를 안정적인 인터페이스 뒤로 감춤으로써 외부의 불필요한 간섭으로부터 내부 상태를 격리할 수 있다.

### 정리
협력에 참여하는 객체의 책임이 자율성을 띄어야 한다. 즉, 객체가 스스로 책임을 수행하는 방법을 결정할 수 있어야 한다.   
한 객체가 다른 객체에게 ‘메시지’로 요청을 전송하고, 수신자 객체는 이를 ‘메서드’로 수행한다.   
메시지와 메서드의 구분은 객체를 외부와 내부의 영역으로 구분하는 동시에, 다형성을 통해 다양한 타입의 객체를 수용할 수 있는 유연성을 부과한다.   
객체가 어떤 메시지를 수신할 수 있느냐가 어떤 책임을 수행할 것인가, 그리고 어떤 인터페이스를 가질 것 인가를 결정한다.   
메시지로 구성된 공용 인터페이스는 객체의 외부와 내부를 명확히 구분함으로서 객체지향의 효과(유연하고 확장 가능한 협력방식/재사용성)를 낼 수 있게 한다.   
=> 책임이 ‘자율적’일수록 협력이 이해하기 쉬워지고, 객체의 외부/내부의 구분이 명확해지며, 변경에 의한 파급효과를 제한할 수 있고, 유연하게 변경할 수 있는 동시에 다양한 문맥에서 재활용할 수 있게 된다.   
=> 추상화 + 응집도 up + 결합도 down + 캡슐화 up + 인터페이스와 구현의 명확한 구분 + 설계의 유연성과 재사용성 up
