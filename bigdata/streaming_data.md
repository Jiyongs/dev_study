## 실시간 데이터 처리

### '실시간' 시스템?
보통 '실시간 시스템을 구현한다'고 했을 때, 데이터가 발생한 그 시점에 바로 클라이언트에게 전달이 되어야 한다고 생각하기 쉽지만 그렇지 않다.   
클라이언트의 네트워크 상태나 애플리케이션 이슈 등으로 데이터를 소비하지 못하는 상태가 되는 등의 여러 가지 예외사항이 많기 때문에 그 정도의 정밀함을 요구하지 않아도 괜찮다.   
실제로 우리가 고민해야 하는 부분은 클라이언트가 원할 때 사용 가능한 시스템을 구현하는 것이다.   
따라서, 실시간 또는 스트리밍 데이터 시스템은 '실시간 또는 실시간보다 약간 느린 데이터 처리 시스템'이다.   
다시 말해, 서버의 실시간 데이터를 클라이언트가 원할 때 사용할 수 있는 시스템이라고 정의할 수 있다.   
> '실시간'이라는 용어의 기준을 더 자세히 분류하자면 수 마이크로-밀리초의 지연만 허용하는 '하드 리얼타임', 수 밀리-초의 지연을 허용하는 '소프트 리얼타임', 수 초-분의 지연을 허용하는 '니어 리얼타임'으로 분류된다.   
하드는 허용 가능한 지연이 거의 없으며, 지연되면 인명 손실 우려가 있는 심박 조율기 같은 시스템이다.   
소프트나 니어는 인명손실 우려가 없기 때문에 약간의 지연을 허용하며, 항공사 예약 시스템이나 화상통화 등의 시스템이 있다.   
결론적으로, 일반적인 실시간 시스템은 소프트나 니어 리얼타임 정도라고 보면 되겠다.

```
<트위터 예시>
1. 트위터에 글을 작성한다.
2. [스트리밍 시스템]은 작성된 글을 처리한다. (정제, 분석, 저장 등)
3. 몇 초 혹은 몇 시간 뒤 [애플리케이션 클라이언트]에서 글을 조회할 때 처리된 데이터를 가져간다.
```

### 스트리밍 시스템 아키텍처
```
[클라이언트 데이터 발생] -> 수집 단계 -> 메시지 큐 단계 -> 분석 단계 -> (장기 스토리지) -> 인메모리 데이터 저장소 -> 데이터 접근 단계 -> [클라이언트 요청 발생]
```
스트리밍 시스템의 아키텍처는 위와 같은 과정을 거친다. 단계별 구현 방법을 알아보자.   

### 수집 단계
#### 수집단계에서 일반적으로 사용되는 5가지 통신 패턴이 있다.
1. 요청/응답 패턴 (Request/Response)   
클라이언트 애플리케이션이 서버에 데이터를 요청하면, 서버가 클라이언트로 응답을 보낸다.   
서버가 지연 없이 즉시 응답하여 작업을 완료하는 것을 목표로 할 때 사용한다.   
간단하지만, 서버가 응답할 때까지 클라이언트는 반드시 기다려야 한다는 단점이 있다.   
그래서 보통은 서버와 클라이언트 양쪽에서 비동기로 처리하는 완전 비동기 요청/응답 패턴으로 구현한다.   
2. 요청/확인응답 패턴 (Request/Acknowledge)   
클라이언트 애플리케이션이 서버에 데이터를 요청하면, 서버가 클라이언트로 응답을 보내며 다음 요청에 활용할 수 있는 부가정보를 같이 응답한다.   
예를 들어, 고객의 클릭 페이지를 통해 구매성향 점수를 계산하고 추천 상품을 제안하는 기능에서 활용될 수 있다.   
```
고객의 클릭 페이지 수집 -> 확인응답으로 고객 고유 식별자를 응답 -> 고객이 상품 구매를 요청 (식별자 같이 전달) -> 확인응답으로 고유 식별자에 매칭된 구매성향 점수를 응답
```
3. 발행/구독 패턴 (Publish/Subscribe)   
Kafka 같은 메시지 기반 데이터 시스템에서 일반적으로 사용된다.   
'토픽'이라는 약속된 공간에 '프로듀서'가 데이터를 전송하고, 그 '토픽'을 구독하고 있던 '컨슈머'가 데이터를 수집한다.   
단, 프로듀서가 토픽에 메시지를 반드시 전송해야하는 것은 아니고 컨슈머도 메시지를 반드시 수집해야 하는 것은 아니다.   
어떤 데이터를 특정 '토픽'에서 주고 받자고 약속된 상태인 것이고, 각자의 역할을 언제 수행하는가는 자유다.   
데이터를 주고 받는 파이프라인이 많은 요즘 시스템에는 이와 같이 프로듀서와 컨슈머 간 결합도(Coupling)를 낮추는 작업이 매우 중요하다.   
4. 단방향 패턴 (One-way)   
요청 시스템에서 데이터를 서버에 보내기만 하고 서버의 응답은 필요하지 않을 때 사용된다.   
예를 들어, 선수의 심박수를 측정하는 시스템에서 심박정보를 1초에 5번씩 서버로 전송해서 그 데이터를 분석하여 경기 해설자에게 분석 결과를 보여주는 시스템이 있다.     
여기서 일부 데이터가 유실된다고 해도 분석 시스템에 큰 영향을 주지 않는다.   
이처럼 단방향 패턴은 일부 데이터가 유실되는 것을 허용하고, 통신을 단순화 하며, 리소스를 감소시키고 전송속도를 보장해야 하는 환경에서 적합하다.   
5. 스트림 패턴 (Stream)   
스트림 원천 데이터에 직접 접근하여 바로 활용할 수 있는 패턴이다.    
#### 수집 단계에서 데이터 처리 신뢰도를 높이기 위해 사용되는 내결함성(Fault-tolerance) 기술을 알아야 한다.
어떤 패턴을 사용하든 수집 서버에서 장애가 발생할 것이고, 수집되는 데이터에 영향이 없도록 처리 신뢰도를 보장하는 구현 방식을 택해야 한다.    
경우에 따라 다르겠지만, 수집 단계에서 데이터를 유실했을 때 그 데이터를 클라이언트에게 다시 요청할 수 없는 경우가 많다. 따라서 내결함성 보장은 매우 중요하다.   
1. 체크포인팅   
단계별 전체 데이터를 캡처한 '전역 스냅샷'을 영속적 저장소에 저장한다. 수집 장애가 발생했을 때 이를 이용하여 복구한다.   
그러나 스트리밍 시스템에서 단계별로 데이터가 이동할 때마다 모든 시점의 데이터를 저장하는 것은 어렵기 때문에(전역 상태 관리 등 복잡성), 스트리밍 시스템에 적합한 방법이라고 볼 수는 없다.   
2. 로깅   
장애가 발생하기 전까지 수신된 마지막 메시지까지 복구하는 기능이다. 로깅은 데이터를 재처리할 수 있는 시점의 마지막 데이터만 저장해두고, 재처리한다.   
대표적으로 RBML, SBML, HML 기술이 있다. 보통 HML 기술을 활용한다.    
2-1) RBML (Receiver-Based Message Logging)   
전달받은 모든 메시지를 저장소에 저장한 이후에 로직을 처리하는 방식이다.   
이 방식은 소프트웨어에 장애가 발생해도 이미 저장된 데이터를 바탕으로 재처리하여 복구할 수 있다.   
2-2) SBML (Sender-Based Message Logging)   
전달받은 메시지를 서버 로직에 따라 처리하고, 처리된 데이터를 다음 단계에 보내기 전에 저장소에 저장하는 방식이다.   
2-3) HML (Hybrid Message Logging)    
RBML과 SBML을 같이 사용하며 하나의 저장소에 데이터를 저장하는 방식이다.   
다만, RBML, SBML은 저장소의 성능(용량, 속도)이 낮은 경우 수집단계에 부정적인 영향을 미칠 수 있기 때문에 저장 단계를 비동기와 멀티코어로 처리한다.   

### 메시지 큐 단계
TODO : 작성 필요

### Reference
앤드류 살티스, '실시간 데이터 파이프라인 아키텍처'
