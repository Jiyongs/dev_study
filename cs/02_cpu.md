## CPU 안에서 일어나는 일
> cpu는 메모리에 저장된 명령어를 읽어 들이고, 해석하고, 실행하는 장치이다. cpu 내부에는 계산을 담당하는 ALU, 명령어를 읽고 해석하는 제어장치, 작은 임시 저장 장치인 레지스터로 구성된다.

### ALU = '계산하다'
ALU가 계산을 하기 위해서는 <피연산자>와 <수행할 연산>이 필요하다.   
그래서 레지스터를 통해 피연산자를 받아들이고, 제어장치로부터 수행할 연산을 알려주는 제어 신호를 받아들인다.   
단, 연산한 결과를 메모리에 바로 저장하지 않고 일단 레지스터에 저장해둔다. 이유는 CPU가 메모리보다 레지스터에 접근하는 것이 더 빠르기 때문이다.   
그리고 연산 결과에 대한 추가적인 상태 정보를 담은 '플래그'를 같이 내보낸다.   
이는 CPU가 프로그램 실행 도중 반드시 기억해야 하는 참고 정보인데, 연산 결과가 음수인지 양수인지 또는 오버플로우가 났는지 등 다양한 정보를 담고 있다.   
|플래그|의미|
|:---:|:---:|
|부호 플래그|연산 결과의 부호|
|제로 플래그|연산 결과가 0인지 여부|
|캐리 플래그|연산 결과 올림수나 빌림수가 발생했는지 여부|
|오버플로우 플래그|오버플로우 발생 여부|
|인터럽트 플래그|인터럽트 가능 여부|
|슈퍼바이저 플래그|커널모드인지 사용자모드인지 여부|

### 제어장치 = '해석하다'
제어장치는 명령어를 읽고 해석해서 제어 신호를 내보내는 역할을 한다.   
보통 아래의 4가지 정보를 읽어들인다.    
1) 클럭 신호   
클럭은 컴퓨터의 부품들이 움직이는 시간 단위이다. '똑-딱-똑-딱' 주기에 맞춰 데이터가 레지스터 간을 이동하거나, ALU에서 연산이 수행되거나, CPU가 메모리의 명령어를 읽어들이거나 한다.   
2) 해석해야 할 명령어   
이 명령어는 명령어 레지스터에 저장되어 있다. 제어장치는 이 명령어 레지스터의 명령어를 받아들이고, 해석한 뒤 제어 신호를 발생시킨다.   
3) 플래그 값    
플래그 레지스터에 있는 플래그를 받아들이고 이를 참고하여 제어 신호를 발생시킨다.   
4) 제어 신호    
제어 신호는 CPU뿐만 아니라 입출력장치와 같은 외부 장치도 발생시킬 수 있다. 이러한 신호들이 시스템 버스 중 제어 버스로 전달되어 제어장치가 받아들인다.   
   
그리고 CPU 내/외부에 제어 신호를 내보낸다.   
외부의 경우, 메모리나 입출력장치의 값을 읽거나 쓰고 싶을 때 제어 버스를 통해 제어 신호를 전달한다.   
내부의 경우, ALU에 수행연산을 지시하고 싶을 때나 레지스터 간 데이터를 이동시키고 저장된 명령어를 해석하고 싶을 때 제어 신호를 전달한다.

### 레지스터 = '임시 저장'
레지스터는 프로그램 속 명령어와 데이터가 실행 전후로 저장되는 공간이다.  
종류가 여러 개 있는데 주요 레지스터 8가지만 알아보자.   
1) 프로그램 카운터   
메모리에서 읽어 들일 명령어의 주소를 저장. 명령어 포인터라고 부르기도 한다. 하나의 명령어 처리가 끝나면, 카운터 값을 증가시켜 다음 명령어의 주소를 읽어들인다.      
2) 명령어 레지스터   
해석할 명령어를 저장.   
3) 메모리 주소 레지스터   
메모리의 주소를 저장. CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거친다.   
4) 메모리 버퍼 레지스터   
메모리와 주고받을 데이터와 명령어를 저장.   
```
<flow 살펴보기>
상황 : 메모리의 (1000번지)에 위치한 명령어 (출력해)를 실행하는 과정
-> [프로그램 카운터]에 명령어의 주소 (1000번지)가 저장된다. 
-> (1000번지)에 있을 명령어를 읽어 들이기 위해 주소 버스를 통해 (1000번지)를 내보내야 한다. 이를 위해 [메모리 주소 레지스터]에 (1000번지)를 저장한다. 
-> (1000번지)와 (메모리 읽기) 제어신호가 각각 주소 버스와 제어 버스를 통해 메모리로 보내진다. 
-> 메모리의 (1000번지)에 저장된 명령어 (출력해)는 데이터 버스를 통해 [메모리 버퍼 레지스터]로 저장된다. 이때, [프로그램 카운터]는 증가되어 다음 명령어를 읽을 준비를 한다.
-> [메모리 버퍼 레지스터]의 (출력해)는 [명령어 레지스터]로 이동한다.
-> 제어장치는 [명령어 레지스터]의 명령어를 해석하고 제어 신호를 발생시킨다.
```
5) 범용 레지스터   
어떤 상황에서도 자유롭게 사용할 수 있는 레지스터. 데이터와 주소를 모두 저장할 수 있다. 일반적으로 CPU는 여러 개의 범용 레지스터를 가지고 있다.
6) 플래그 레지스터   
ALU 연산 결과에 따른 플래그를 저장. 
7) 스택 포인터   
스택의 꼭대기(마지막으로 저장된) 값의 위치를 저장. 스택은 메모리에 '스택 영역'을 할당받아 사용할 수 있는데, 이 영역은 주소 공간과는 다르게 스택처럼 사용하기로 암묵적으로 약속된 영역이다.   
스택 포인터를 이용하여 해당 영역의 주소를 지정하는 방식을 '스택 주소 지정 방식'이라고 한다.
8) 베이스 레지스터   
베이스 레지스터 주소 지정 방식에서 '기준 주소'를 저장. 주소 지정 방식 중에 '변위 주소 지정 방식'이 있는데 그 중 하나인 '베이스 레지스터 주소 지정 방식'은 베이스 레지스터에 저장된 기준 주소와 오퍼랜드 필드에 저장된 주소 변위값을 더하여 메모리의 주소를 얻는 방식이다.

### CPU의 실제 모습을 알아두자
CPU는 제조사마다 각 레지스터를 칭하는 용어가 다르기 때문에, 실제로 사용되는 CPU를 분석하기 위해서는 책에서 배운 개념만으로는 쉽지 않다.   
따라서 가장 대중적인 CPU(x86, ARM 등)의 실제 레지스터 구성을 살펴보길 권장한다고 한다.   
[참고자료](https://github.com/kangtegong/self-learning-cs/blob/main/registers/registers.md#%EB%8C%80%ED%91%9C%EC%A0%81%EC%9D%B8-arm-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0)

### Reference
강민철, '혼자 공부하는 컴퓨터구조+운영체제'
